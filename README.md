# 面试真题

[toc]



## 1、腾讯-天美工作室群IEG-一面 2025.3.6

### 1.1、protobuf序列化和反序列化过程，json和protobuf的使用场景

Protobuf序列化原理简介：

> 序列化：序列化是将数据结构或对象转换成二进制字节流的过程。
> Protobuf对于不同的字段类型采用不同的编码方式和数据存储方式对消息字段进行序列化，以确保得到高效紧凑的数据压缩。
> Protobuf序列化过程如下：
> (1)判断每个字段是否有设置值，有值才进行编码。
> (2)根据字段标识号与数据类型将字段值通过不同的编码方式进行编码。
> (3)将编码后的数据块按照字段类型采用不同的数据存储方式封装成二进制数据流。
> ————————————————原文链接：https://blog.csdn.net/weixin_43971373/article/details/119729776
>
> 1.2反序列化
> 反序列化是将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。
> Protobuf反序列化过程如下：
> (1)调用消息类的parseFrom(input)解析从输入流读入的二进制字节数据流。
> (2)将解析出来的数据按照指定的格式读取到C++、Java、Phyton对应的结构类型中。

Protobuf数据存储方式

>T-L-V(Tag - Length - Value)，即标识符-长度-字段值的存储方式，其原理是以标识符-长度-字段值表示单个数据，最终将所有数据拼接成一个字节流，从而实现数据存储的功能。
>其中Length可选存储，如储存Varint编码数据就不需要存储Length，此时为T-V存储方式。
>
>T-L-V 存储方式的优点：
>A、不需要分隔符就能分隔开字段，减少了分隔符的使用。
>B、各字段存储得非常紧凑，存储空间利用率非常高。
>C、如果某个字段没有被设置字段值，那么该字段在序列化时的数据中是完全不存在的，即不需要编码，相应字段在解码时才会被设置为默认值。
>
>**Tag是消息字段标识符和数据类型经Varint与Zigzag编码后的值**，因此Tag存储了字段的标识符(field_number)和数据类型(wire_type)，即Tag = 字段数据类型(wire_type) + 标识号(field_number)。

![img](https://i-blog.csdnimg.cn/blog_migrate/f43ec9e9222d3b1cfd5925c3aec8d524.png)

1. 先取到message的discriptor
2. 根据message的discriptor，取出所有field的discriptor------》放入vector中
3. 有了message和field，去找定给定field的所有字段，实际上得到的是字段到message的偏移量
4. 那么根绝message的首地址和偏移量，再将其转换为字段的类型，就得到了这个字段的指针
5. 再解引用就得到值

**前向兼容和后向兼容：**：

> 对于服务端返回字段不确定的情形，有几种方法可以处理，而无需频繁升级客户端
>
> 1. 使用 **Any** 类型，可以将不确定的字段封装在 Any 类型中，这样即使客户端添加了新的字段类型，客户端也可以解析已知字段，而忽略不认识的 Any字段
> 2. 使用 **oneof** 结构，如果返回的类型是有限的几种，可以使用 oneof 来定义这些可能的字段，这样客户端可以解析它认识的字段，并忽略不认识的字段
> 3. 扩展字段：Protobuf也支持扩展字段，这允许你在不破坏向后兼容性的情况下添加新的字段，客户端可以忽略他不理解的扩展字段
> 4. 使用包装类型，对于可选的字段，可以使用Protobuf的包装类型，如 google.protobuf.StringValue、Int32Value等，这样即使某些字段在某些情况下不被设置，也不会破坏消息的格式

toString---》二进制字段写值，**属性的名称**实际上对应的是**message中字段的id**，动态反射（基类调用其他类的方法）。

**应用场景：**

1. 客户端<-->服务端，为了方便灵活，比如 服务端返回的字段，经常更新，不可能要求客户端一并更新，这时协议是松散的，适合用json
2. 服务端1<-->服务端2，服务端是由开发人员维护的，可以做到同时一并升级，服务端的RPC框架传输，可以使用protobuf

<span style="color:red">Protobuf不支持动态解析，在编码和解码时需要预先定义数据结构，因此它不支持像JSON那样可以动态地解析任意结构的数据。这在处理一些需要灵活处理数据结构的场景时可能会受到限制。这项绝对导致，他不适合客户端<-->服务端之间的通讯，因为接口会经常更新，变化，不能动态适应，导致客户端也需要升级，是不现实的。</span>

JSON灵活，Protobuf高效，性能好，体积小。



### 1.2、如果查看一个已经运行的进程中某一个线程CPU的占用率？代码怎么大致计算？

使用Linux系统命令查看

```shell
# 1.首先查看 PID
#在最后一栏中可以看到进程名和进程的PID
netstat -tnlp -all
#或者第四列就是进程的PID
ps -ef -all

# 2.通过PID查看该进程下，运行的线程号SPID
ps -T -p 进程ID 
#或者
ps -eLf|grep 进程PID



#或者直接通过top命令查看，第一列是进程号是线程的PID
top -H -p 进程PID


#通过树状结构查看
pstree -p 5010
```



代码实现：

> 通过读取/proc/stat文件获取当前系统的CPU占用率。
>
> > proc是一个只存在内存当中的伪文件系统，他以文件系统的方式为内核与进程提供通信的接口。用户和应用程序可以通过/proc得到动态的从系统内核读出的系统的信息，并可以改变内核的某些参数
>
> > /proc/stat 包含了系统启动以来的许多关于kernel和系统的统计信息, 其中包括**CPU运行情况**、中断统计、启动时间、上下文切换次数、运行中的进程等等信息。其实，/proc/stat反映的就是CPU总的占用时间，如下图所示。
> >
> > ![Alt](https://i-blog.csdnimg.cn/blog_migrate/6e957daa670bd41eeb65872fa366ca4c.png#pic_center)
> >
> > **参数      解析（单位：jiffies）**
> >
> > (jiffies是内核中的一个全局变量，用来记录自系统启动一来产生的节拍数，在linux中，一个节拍大致可理解为操作系统进程调度的最小时间片，不同linux内核可能值有不同，通常在1ms到10ms之间)
> >
> > **user** (12939774)  从系统启动开始累计到当前时刻，处于用户态的运行时间，不包含 nice值为负进程。
> >
> > **nice** (3709)   从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间
> >
> > **system** (18395244) 从系统启动开始累计到当前时刻，处于核心态的运行时间
> >
> > **idle** (842761120)  从系统启动开始累计到当前时刻，除IO等待时间以外的其它等待时间**iowait** (17500556) 从系统启动开始累计到当前时刻，IO等待时间(since 2.5.41)
> >
> > **irq** (0)      从系统启动开始累计到当前时刻，硬中断时间(since 2.6.0-test4)
> >
> > **softirq** (49424)   从系统启动开始累计到当前时刻，软中断时间(since2.6.0-test4)
> >
> > **stealstolen**(0)           which is the time spent in otheroperating systems when running in a virtualized environment(since 2.6.11)
> >
> > **guest**(0)                whichis the time spent running a virtual CPU for guest operating systems under the control ofthe Linux kernel(since 2.6.24)

**CPU利用率的计算**

CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和<span style="color:red">空闲系统进程</span>执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。

通过线程ID获得各线程的CPU使用率。

主要是通过分析**/proc/<pid>/task/<tid>/stat**文件获得，pid为程序的PID，tid为程序的各个线程的ID号（就是第一步输出的线程ID），stat文件就是一些调度的基本信息，具体可参阅：Linux proc/pid/task/tid/stat文件详解 http://blog.csdn.net/ctthuangcheng/article/details/18090701

线程比较多的时候一个线程一个线程去分析该文件比较费劲，可通过脚本一次解析完成，参数为进程PID，运行成功会输出该进程的所有线程tid、用户层CPU使用、内核态CPU使用，数值越高表示消耗CPU资源越多。

```shell
# 嵌入线程中进行线程CPU各占用率的输出
#!/bin/sh
#get /proc/pid/task/tid/stat
#$1 is tid
#$14  is user cpu 
#$15 is sys cpu
echo "tid user sys"
for file in /proc/$1/task/*
do
    if test -d $file
    then
        cat $file/stat | awk -F" " '{print $1 " " $14 " " $15}'
    fi
done
```

**线程Cpu时间threadCpuTime = utime +stime**



### 1.3、如何查看一个进程已经打开的文件描述符的数量

**获取系统打开的文件描述符数量**

```sh
  [root@localhost ~]# cat /proc/sys/fs/file-nr 

  1216  0    197787

   //第一列 1216  ：为已分配的FD数量

   //第二列 0     ：为已分配但尚未使用的FD数量

   //第三列197787：为系统可用的最大FD数量

  已用FD数量＝为已分配的FD数量 - 为已分配但尚未使用的FD数量。注意，这些数值是系统层面的。
```

**获取进程打开的文件描述符数量**

```sh
    [root@localhost ~]# pidof vim

      3253

    [root@localhost ~]# ll /proc/3253/fd

     总用量 0

    lrwx------. 1 test test 64  6月  8 18:11 0 -> /dev/pts/0

    lrwx------. 1 test test 64  6月  8 18:11 1 -> /dev/pts/0

    lrwx------. 1 test test 64  6月  8 18:11 2 -> /dev/pts/0

    lrwx------. 1 test test 64  6月  8 18:11 4 -> /home/test/.bash_history.swp

    //可以看到vim进程用了4个FD
```

**获取整个系统打开的文件数量**

```sh
 [root@localhost ~]# lsof |wc -l

    1864
```

**获取某个用户打开的文件数量** 

```sh
  [root@localhost ~]# lsof -u test |wc -l

   15
```

**获取某个程序打开的文件数量** 

```sh
  [root@localhost ~]# pidof vim

   3253

  [root@localhost ~]# lsof -p 3253 |wc -l

   31
```

上面所示只是用lsof来显示已打开的文件数量，lsof的功能远不止这些，有兴趣可以man lsof看一下 

### 1.4、手撕循环队列

```c++
#define MAX_SIZE 10

class Queue{
public:
  Queue(){
    arr_ = new int[MAX_SIZE];
    head_=0;
    tail_=0;
  }
  
  ~Queue(){
    delete[] arr_;
  }
  
  void insert(int&& val){
    arr_[tail_] = val;
    tail_ = (tail_+1)%MAX_SIZE;
  }
  
  int get(){
    int temp = arr_[head_];
    head_ = (head_+1)%MAX_SIZE;
    return temp;
  }
  
  bool isFull(){
    return (tail_+1)%MAX_SIZE == head_;
  }
  
  bool isEmpty(){
    return head_==tail_;
  }
  
private:
  int *arr_;
  int head_,tail_;
}
```

### 反问

1. 主要的工作内容是什么
2. 后台开发和游戏后台开发的区别是什么



## 2、柠檬微趣-C++服务端开发实习 2025.3.11

### 2.1、字符与字符串对应
给定一个字符串，和一个由多个单词组成的字符串，如果字符串中的字符与单词一一对应，那么说明这个是匹配的，返回True，反之不匹配，返回false
> "abc" "good study day"
> True
> "abc" "good good study"
> False

```c++
bool isMatch(string a,string b)
{
    istringstream is(b);
    vector<string> words;
    string temp;
    while(is>>temp)
        words.emplace_back(temp);
    unordered_map<char,string> ctow;
    unordered_map<string,char> wtoc;
    for(int i = 0;i<a.size();i++)
    {
        if(ctow.find(a[i])==ctow.end()&&wtoc.find(words[i])==wtoc.end())
        {
            ctow[a[i]] = words[i];
        }
        else
        {
            if(ctow.find(a[i])!=ctow.end()&&wtoc.find(words[i])!=wtoc.end())
            {
                if(ctow[a[i]] == words[i]&&wtoc[words[i]]==a[i])
                    continue;
                else
                    return false;
            }
        }
    }
    return true;
}
```

### 2.2、下一个更大元素 力扣556


### 2.3、最小两个连续子数组长度和  力扣1477


### 2.4、ProtocolBuffer序列化



## 3、某初创小型量化-量化系统开发实习生 2025.3.14-接了实习了4个月

### 3.1、池式结构的介绍

主要介绍了连接池、线程池、内存池，协程池稍微提了一下，因为不太清楚实现的协程池是否正确。

连接池：为了避免连接的频繁创建与销毁所带来的开销。预先创建一定的连接数量供给用户使用，在用户使用完后不进行销毁重新放入队列，供给后续用户接着使用。

线程池：与连接池同理。用户提交自己的自定义任务到任务队列中，线程池中的空闲线程收到条件变量的通知后，唤醒拿取任务执行，用户通过future类型拿取任务的执行结果。在任务繁忙时，线程池会动态创建新的线程（低于最大数量的线程）来分担任务的处理。在空闲一段时间后，对超过默认数量的线程资源进行回收。

内存池：参考STL 二级空间配置器的实现，通过静态链表串起不同大小的内存块（内存对齐），以8字节作为基础。在分配的时候有多种策略信息。充分利用内存空间，尽可能减少内存碎片的产生。

协程池：使用boost的context库来实现协程的上下文保存和切换动作。与epoll结合，当epoll监听到相关的读写事件，通过协程上下文中的函数指针指向对应的处理函数来进行处理。（协程这儿感觉实现有点问题）



### 3.2、连接池详细追问

记不太清了，好像是让我讲了一下详细实现？？？？跟上面的内容差不多。



### 3.3、线程池详细追问-线程数量的限制与线程执行任务数量

线程一次只能拿取一个任务执行，如果需要考虑任务的优先级相关信息，可以考虑先来先服务、带有优先级的优先级任务队列，响应比算法进行任务的优先级调度。



### 3.4、内存池详细追问-主要针对内存碎片处理的问题

举例说明：如果一个用户申请5字节的对象，申请在8字节的chunk块下，实际上只会占据5字节，产生3字节的内存碎片（内存对齐所产生的内碎片）。然后在用户在使用内存池中的内存后，剩下比如说16字节的内存，再申请32字节的对象大小时，该15字节的内存块将被串进16字节的chunk块中，重复该动作，16字节的chunk块中被串进了两个16字节的chunk块，但不连续。只有用户在申请小于等于16字节的对象大小时会消耗该内存块。实际上这两个内存块能分配32字节的对象。（外碎片的产生）



### 3.5、网络编程epoll的连接量如何测试的，以及如何查看打开的文件描述符

[服务器百万并发实现](https://blog.csdn.net/qq_42956653/article/details/125653754)，最重要的一点如何在一台服务器上建立百万连接。一个socket标识最终取决于<源ip，源端口，目的ip，目的端口>，而在一个端口下能建立多个socket标识，只需要保证socket的四元组唯一即可。例如在客户端，可以通过所有的端口向服务器发起连接（这一步实际上是系统自己实现的，自动随机分配），然后每一个端口均可建立多个连接，这样一来，客户端大概2.8w端口，连接服务端的100个端口，按理来讲就能连接280w了。

查看打开文件描述符可以参考腾讯一面。



### 3.6、针对网络IO，Linux系统的操作流程或者网络数据在Linux内部是如何流转的

应用程序将用户数据拷贝到内核，内核通过协议栈自动对数据包进行分段，分包封装，然后通过网卡进行数据的发送。在接收到网络上的数据时，通过网卡读取操作，然后进行数据包的解析相关操作。最终解析到内核缓冲区，再拷贝到用户数据区提供给用户程序进行使用。



### 3.7、网络IO主要的时延在哪，如何改进

IO操作的开销，用户态和内核态的切换。
DPDK网卡旁路技术，可以在用户态开辟一块内存直接接收网卡的数据，避免网卡到内核再到用户态的拷贝开销。



### 3.8、高并发和低时延矛盾吗？为什么？

矛盾，高并发是满足更多用户的连接使用，低时延是尽快的给用户提供服务。服务器的开发更多是找到高并发和低时延的一种折中。



### 3.9、MySQL和Hadoop的区别在哪，如何优化MySQL的查询？或者关系型数据库和非关系型数据库的区别在哪？

这个没答上来，只回答了一下MySQL是B+树索引，MySQL的优化

1. explain sql语句，查看sql语句执行的具体流程和耗时逻辑
2. 添加索引，保证sql语句的书写满足索引的最左原则。

### 3.10、Linux系统调优有了解过吗？具体讲讲

了解过，看过一些文章，例如更改文件描述符的数量，线程所占栈空间的大小等。

（面试官提到：更多的是如何结合硬件去调优，而不是仅仅更改参数设置，DPDK就是直接结合硬件做改进）

### 反问

1. 对于量化来说，Linux系统具体调优方向是什么
2. 操作系统内核的改进重要吗，应用层更为重要还是内核更为重要



## 4、快手-C++开发（搜索广告方向）-一面 2025.3.20

### 手撕：岛屿的数量

### 4.1、池式结构项目详细介绍一下

### 4.2、线程池项目中，互斥锁和条件变量的使用详细讲一下

临界资源的访问需要进行保护

### 4.3、线程池扩容的策略是什么？

维护了一个原子变量记录空闲线程的数量，当用户提交任务时超时等待5s，如果没有空闲线程且线程池中维护的线程数量还未超过最大值，那么创建新的线程来执行。如果线程池中维护的线程数量已经达到了最大值，那么返回给用户当前系统忙，稍后再试。

### 4.4、刚才你提到另外有一个分离的定时扫描线程来进行多余线程资源的回收，考虑这样一个情况，假设定时时长为60s，每60s进行一次扫描，每一分钟仅有开始的第1～2s有非常多的任务数量，其余时间没有任务，那么剩下的这五十多秒内，多余的线程资源都是空闲的，该如何解决这种问题？

根据任务数量进行定时参数的更新，例如任务数量多时扫描间隔时间长，任务数量少时，扫描间隔时间短。可以通过Boost库中实现的无锁队列进行任务的提交与拿取（原子化操作）。将任务分开为IO密集型任务和CPU密集型任务，多分类任务的线程池，添加优先级队列。

（面试官提到：可以去看看开源的线程池代码，例如Folly线程池源码，还有libunifix executor）

### 4.5、在进行notify_all时容易造成惊群现象，为什么使用notify_all，notify_one对应的缺点在哪？

notify_one容易造成互斥锁的抢用被用户拿取，造成任务队列执行的饥饿现象。也就是锁一直被用户提交任务拿取，每次唤醒的唯一一个线程无法抢占锁得以消费任务，造成饥饿现象。notify_all造成惊群现象的改进需要进行线程池的改进。

### 4.6、介绍一下聊天室项目。

利用muduo网络库的提供网络层服务，通过注册回调解耦网络层与业务层。

在此基础上，使用epoll和协程进行网络服务的重写，同时利用protobuf进行RPC框架的搭建

### 4.7、Protobuf的具体使用情况，JSON与Protobuf的区别

protobuf适用于可以便于扩展内部系统，相同的数据量所占的大小远远小于json，同时字段的数据类型确定，扩展时向前兼容、向后兼容。

### 4.8、nginx的均衡策略有其他了解吗？一致性哈希的优点有什么？

轮询、权重、一致性哈希

不了解，只知道当新增加服务器时，需要做数据迁移时要用到一致性哈希。

###4.9、讲一下epoll的优点

先讲select数组，有最大数量限制，然后poll链表无数量限制，但select和poll都需要全部进行用户态和内核态的拷贝。

epoll将监听的文件描述符结构维护在内核态，通过事件监听将发生事件的文件描述符拷贝至用户态，避免了频繁的拷贝开销。同时支持ET和LT模式，LT更安全，ET性能更高。ET发生事件只通知一次，程序员需要对数据进行完整的读取。LT有数据一直通知，将会降低epoll_wait的处理性能。

###反问：

部门的方向是什么，与搜广推基础架构方向的区别是什么？

> 主要的工作方向为广告，需要在海量的广告库中根据用户的query得到最匹配的广告，推荐给用户

实习生主要做的工作是什么

> 学习相关的工作内容，寻找新的feature进行开发



## 5、腾讯wxg-技术架构-后台开发-一面 2025.3.21

### 手撕

1. atoi的实现
2. 合并有序链表
3. rand()产生0～2^16-1的随机数，设计一个可以运行的算法从30万员工中（编号1～30万）抽出10万个员工，一位员工只能被抽中一次
4. 有一个非常大的数据集（无法被完全装入内存），为数组。提供一个接口ReadNext()。数组中的每个元素为一个结构体，包含三个信息，用户的id、时间戳、事件。事件有登陆和登出两种，给一个24小时的数据，找出瞬时用户在线数量的最大值

### 5.1、C++11的新特性有哪些，或者项目中用到了哪些详细讲讲

shared_ptr的自定义析构函数，将连接重新放入连接队列中，对用户透明化。

### 5.2、我看你用到了可变参模版编程，模版元编程有了解过吗？SFINAE

不了解

### 5.3、协程池的项目实现，boost库的使用
### 5.4、gdb死锁的发生，讲一下怎么判断死锁

gdb attach->info threads->thread i->bt（查看线程调用堆栈信息）

### 5.5、Map底层实现

### 5.6、讲一下epoll的优缺点
### 5.7、讲一下连接量的测试，QPS测试了吗



### 反问：
1、技术架构部门主要的工作内容为什么

> 我们组主要做消息中间件的开发，做消息通道，偏向于底层技术支持模块，很多上层的应用需要用到我们的消息通道

## 6、字节跳动-番茄小说-后端开发实习生-一面2025.7.16
### 手撕：str转float，需要有异常处理格式

### 6.1、量化系统开发实习主要工作是啥

量化交易系统的开发，掌握数据链路的时延，开发低时延平台。
> 使用异步持久化机制，如果需要持久化的数据map过大，在拷贝的时候拿取自旋锁会不会等待时间过长，时延过大，如何解决这个问题？
> 
> 使用缓冲队列，在拷贝的时候不阻塞主线程，将请求放入一个队列中拷贝完成后用队列中的数据更新map以获取最新的map映射表。拷贝的时候可以用读锁进入，拷贝过程有写锁，队列更新需要获取写锁后再进行
### 6.2、讲一下你简历中项目你觉得最有挑战的或者映像最深刻的
> 主包将线程池和连接池实现说叉了，使用shared_ptr<>的自定义析构函数来将数据库的连接重新放回连接队列中，供后续服务使用，线程池的设计问题。
> 
> shared_ptr与weak_ptr，为什么要有weak_ptr？------》shared_ptr主要是为了资源共享，weak_ptr是弱引用计数，不会增加共享指针的计数信息，可以解决shared_ptr的循环引用造成的无法释放资源导致的内存泄露问题

### 6.3、epoll、select、poll

### 6.4、redis用作消息队列，redis的持久化过程，rabbitMQ的持久化过程与rabbitMQ的部署方式有哪些

### 6.5、智能指针weak_ptr用来做啥

### 6.6、讲一讲共享内存底层实现（fd文件描述符）

### 反问

主要业务是什么？为什么番茄小说在微信小程序上没官方程序，与微信读书的区别在哪

> 面向B端，做B端的后端开发
>
> 区别：内容更广泛，增长方式更狂野

## 7、字节跳动-番茄小说-后端开发实习生-二面2025.7.21

> 面试体验不好：面试官没有任何提前兴趣，自我介绍时开始看简历，没有反问环节，着急退出会议室；本人简历是C++，感觉面试官不会C++

### 手撕：两个字符串交错是否可以形成目标串

### 7.1、讲一下实习

### 7.2、讲一下输入网址后的流程，越详细越好

### 7.3、DNS原理，使用什么协议来获取IP

### 7.4、进程间通信的方式有哪些

### 7.5、讲一下EPOLL

无反问，忘了，反正体验不好，面完20分钟感谢信

## 8、字节跳动-抖音推荐架构开发-一面2025.8.7

> 不错，面试体验很好，互相学习！

### 手撕：线程池（吭哧吭哧把大体逻辑写了，面试官问还可以怎么优化）

### 8.1、讲一下量化系统开发实习

### 8.2、cgroups和内存对齐具体做了什么

### 8.3、无锁队列实现了什么，用的什么

### 8.4、项目中用了协程，怎么实现的？知道C++20的协程吗

项目实现用的ucontext，有栈对称交换的协程，实际上是栈指针的切换；C++20的协程是无栈协程，非对称交换

### 8.4、C++有哪些优化的地方

> 本人说了用array少用vector、无锁、内存对齐、通信消耗----》面试官：inline内联、减少虚函数、map优化（本人实习时把map全改为vector了，与面试官做的优化逻辑一样，不错儿👍）

### 8.5、std::move

### 8.6、gdb调试处理core dump文件

### 8.7、常见的消息中间件有哪些？各有什么优劣，简单讲讲

### 反问

> 部门主要业务是什么？C++如何提升？
>
> 主要业务做在线的推荐架构，特征的精筛粗筛等，对性能比较敏感，需要很强的代码质量与设计；如何提升：多写，了解C++新版本特性，因为组内已经开始用C++20了😧

## 9、蚂蚁集团-OceanBase底层引擎开发-2025.8.12

### 手撕：有环单链表判断环的大小

全程聊实习，问细节，为什么这么做，为什么原理是什么？

有一个问题没答上来：

### 9.1、消息中间件消息被消费时，如果是广播，与消费者解耦，删除消息的时机是什么
RabbitMQ关键机制是`fanout`会在所有队列中保存消息的副本，ack确认后删除自己的即可
队列的消息只能被一个消费者获取消费！不会推送给所有消费者！

### 反问

主要工作内容？C++提升方向

主要工作内容为文件存储，规划存储，可以简单理解做共享存储的底层；提升方向：来公司实习，长时间做下去，会有很多收获

## 10、阿里-淘天集团-全栈开发工程师-2025.8.13-一面

> 中午面，当天约晚上二面

### 手撕：构造树结构，写DFS与BFS遍历，输出遍历路径

### 10.1、讲一下new操作，从语言到操作系统做了哪些事情

### 10.2、讲一下进程与线程的区别

### 10.3、讲一下OS的内存管理，以及你了解的内存管理策略（ptmalloc、tcmalloc、jemalloc）

### 10.4、epoll和select的区别

### 10.5、实习中的难点和亮点，收获是什么

### 10.6、map和unordered_map的底层实现和插入的时间复杂度是多少

### 10.7、AI了解什么，做过哪些大模型

### 反问

> 部门主要工作内容？C++提升？
>
> 部门主要工作是写C++和Python，淘宝直播技术团队，做AIGC的落地应用与一些调度的工作；C++提升针对具体场景来说，编码和一些新特性进展

## 11、阿里-淘天集团-全栈开发工程师-2025.8.13-二面

> 纯聊天，问意愿，工作内容巴拉巴拉；面试官非常详细的介绍了整个部门的工作内容，做直播数字人的，AIGC方向，偏向音视频处理？

### 无手撕

## 12、虾皮-EI引擎开发工程师-2025.8.14

### 手撕：文件目录的匹配

> 例如：["/x","/x/y","/a/b/c","/a/b"]--->返回["/x","/a/b"] ---->即返回目录具有包含关系的最上层目录

### 12.1、map的底层实现，跳表了解吗，插入时跳表的索引是怎么更新的

> 多级索引的单链表，索引是在插入时结点按照概率计算该结点会成为几级索引然后创建索引，索引的创建是随机的

### 12.2、MYSQL的聚簇索引和非聚簇索引，聚簇索引是什么，讲一下平时开发中考虑的点

> 把聚簇索引和非聚簇索引，包括联合索引全讲了（这里讲错一个，如果有主键，聚簇索引就是主键，如果没有主键，那么不为NULL的列作为聚簇索引，如果都没有，MySQL会自己生成一列自增的id作为聚簇索引）；
>
> 然后讲回表、索引下推，覆盖索引，limit offset拷贝优化，巴拉巴拉一堆，把能想到的都讲了

### 12.3、假设用EPOLL开发一个网络服务，如何管理10万个连接

> Reactor&Peactor讲了一遍，事件分发巴拉巴拉

### 12.4、异步IO，IO_uring讲一下，平常开发中有使用吗

### 12.5、我需要对EPOLL管理的10万个连接，回收超过30s不活跃的连接，怎么做

> 定时器加优先级队列（最大堆）

### 反问

> 问题问的不好，面试官不知道如何回答
>
> NoSQL和蚂蚁的OceanBase区别与优势？做存储需要学习什么内容，提升哪些方面？



## 13、字节跳动-抖音推荐架构开发-二面2025.8.14

> 全是开放性提问，提问20分钟，开始做题

### 手撕

1. 一个数组，数字都是两两连续出现，找出唯一一个仅出现一次的数字，输出其所在下标（要求最优解）----》分治，根据左右两侧数量来二分
2. 一个含有N种类型的消息队列，分发到M个队列中，具有以下三个要求----》用堆维护队列的类型种类，最小堆，从堆顶取种类，然后看看种类与消息类型与消息数量是否满足条件，维护一个最大的class_num，进行更新（设计题，说出大致实现思路即可，无需写代码）
   1. 让消息均匀的分配给M个队列，即最大消息数为 总消息数量/M
   2. 让每个队列中消息类型尽可能相等
   3. 同一种类型的消息尽可能放在同一个队列中
      - 优先级：1>2>3
3. 给定两个字符串，一次删除操作可以删除一个字符，最少需要删除几次让两个字符串相同---》最长公共子序列变形

### 13.1、实习的内容收获

### 13.2、人际关系如何

### 13.3、想做什么，你觉得一个好的系统架构需要具备什么特点

### 13.4、让你设计一个系统，你需要考虑哪些重要的点

### 反问

> 实习生的主要工作内容？您觉得一个好的系统架构需要具备什么特点？
>
> 主要工作内容很广泛，为抖音或者整个公司提供架构服务，需要密切对接算法部门，看实习生的兴趣和自我驱动；
>
> 好的系统架构需要很好的解决一个具体的业务场景，一个好的轮子需要具有不可替代性，如果一个轮子很容易被替代那说明这个轮子不够好